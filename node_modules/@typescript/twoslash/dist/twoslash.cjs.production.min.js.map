{"version":3,"file":"twoslash.cjs.production.min.js","sources":["../src/utils.ts","../src/index.ts","../src/validation.ts"],"sourcesContent":["import { TwoslashError } from \"./\"\n\nexport function escapeHtml(text: string) {\n  return text.replace(/</g, \"&lt;\")\n}\n\nexport function strrep(text: string, count: number) {\n  let s = \"\"\n  for (let i = 0; i < count; i++) {\n    s += text\n  }\n  return s\n}\n\nexport function textToAnchorName(text: string) {\n  return text\n    .toLowerCase()\n    .replace(/ /g, \"-\")\n    .replace(/`|#|\\//g, \"\")\n}\n\nexport function fileNameToUrlName(s: string) {\n  return s.replace(/ /g, \"-\").replace(/#/g, \"sharp\").toLowerCase()\n}\n\nexport function parsePrimitive(value: string, type: string): any {\n  switch (type) {\n    case \"number\":\n      return +value\n    case \"string\":\n      return value\n    case \"boolean\":\n      return value.toLowerCase() === \"true\" || value.length === 0\n  }\n\n  throw new TwoslashError(\n    `Unknown primitive value in compiler flag`,\n    `The only recognized primitives are number, string and boolean. Got ${type} with ${value}.`,\n    `This is likely a typo.`\n  )\n}\n\nexport function cleanMarkdownEscaped(code: string) {\n  code = code.replace(/¨D/g, \"$\")\n  code = code.replace(/¨T/g, \"~\")\n  return code\n}\n\nexport function typesToExtension(types: string) {\n  const map: Record<string, string> = {\n    js: \"js\",\n    javascript: \"js\",\n    ts: \"ts\",\n    typescript: \"ts\",\n    tsx: \"tsx\",\n    jsx: \"jsx\",\n    json: \"json\",\n    jsn: \"json\",\n  }\n\n  if (map[types]) return map[types]\n\n  throw new TwoslashError(\n    `Unknown TypeScript extension given to Twoslash`,\n    `Received ${types} but Twoslash only accepts: ${Object.keys(map)} `,\n    ``\n  )\n}\n\nexport function getIdentifierTextSpans(ts: typeof import(\"typescript\"), sourceFile: import(\"typescript\").SourceFile) {\n  const textSpans: { span: import(\"typescript\").TextSpan; text: string }[] = []\n  checkChildren(sourceFile)\n  return textSpans\n\n  function checkChildren(node: import(\"typescript\").Node) {\n    ts.forEachChild(node, child => {\n      if (ts.isIdentifier(child)) {\n        const start = child.getStart(sourceFile, false)\n        textSpans.push({ span: ts.createTextSpan(start, child.end - start), text: child.getText(sourceFile) })\n      }\n      checkChildren(child)\n    })\n  }\n}\n\nexport function stringAroundIndex(string: string, index: number) {\n  const arr = [\n    string[index - 3],\n    string[index - 2],\n    string[index - 1],\n    \">\",\n    string[index],\n    \"<\",\n    string[index + 1],\n    string[index + 2],\n    string[index + 3],\n  ]\n  return arr.filter(Boolean).join(\"\")\n}\n\n/** Came from https://ourcodeworld.com/articles/read/223/how-to-retrieve-the-closest-word-in-a-string-with-a-given-index-in-javascript */\nexport function getClosestWord(str: string, pos: number) {\n  // Make copies\n  str = String(str)\n  pos = Number(pos) >>> 0\n\n  // Search for the word's beginning and end.\n  var left = str.slice(0, pos + 1).search(/\\S+$/),\n    right = str.slice(pos).search(/\\s/)\n\n  // The last word in the string is a special case.\n  if (right < 0) {\n    return {\n      word: str.slice(left),\n      startPos: left,\n    }\n  }\n  // Return the word, using the located bounds to extract it from the string.\n  return {\n    word: str.slice(left, right + pos),\n    startPos: left,\n  }\n}\n","let hasLocalStorage = false\ntry {\n  hasLocalStorage = typeof localStorage !== `undefined`\n} catch (error) { }\nconst hasProcess = typeof process !== `undefined`\nconst shouldDebug = (hasLocalStorage && localStorage.getItem(\"DEBUG\")) || (hasProcess && process.env.DEBUG)\n\ntype LZ = typeof import(\"lz-string\")\ntype TS = typeof import(\"typescript\")\ntype CompilerOptions = import(\"typescript\").CompilerOptions\ntype CustomTransformers = import(\"typescript\").CustomTransformers\n\nimport { parsePrimitive, cleanMarkdownEscaped, typesToExtension, getIdentifierTextSpans, getClosestWord } from \"./utils\"\nimport { validateInput, validateCodeForErrors } from \"./validation\"\n\nimport { createSystem, createVirtualTypeScriptEnvironment, createFSBackedSystem } from \"@typescript/vfs\"\n\nconst log = shouldDebug ? console.log : (_message?: any, ..._optionalParams: any[]) => \"\"\n\n// Hacking in some internal stuff\ndeclare module \"typescript\" {\n  type Option = {\n    name: string\n    type: \"list\" | \"boolean\" | \"number\" | \"string\" | Map<string, any>\n    element?: Option\n  }\n\n  const optionDeclarations: Array<Option>\n}\n\ntype QueryPosition = {\n  kind: \"query\" | \"completion\"\n  offset: number\n  text: string | undefined\n  docs: string | undefined\n  line: number\n}\n\ntype PartialQueryResults = {\n  kind: \"query\"\n  text: string\n  docs: string | undefined\n  line: number\n  offset: number\n  file: string\n}\n\ntype PartialCompletionResults = {\n  kind: \"completions\"\n  completions: import(\"typescript\").CompletionEntry[]\n  completionPrefix: string\n\n  line: number\n  offset: number\n  file: string\n}\n\ntype HighlightPosition = TwoSlashReturn[\"highlights\"][number]\n\nexport class TwoslashError extends Error {\n  public title: string\n  public description: string\n  public recommendation: string\n  public code: string | undefined\n\n  constructor(title: string, description: string, recommendation: string, code?: string | undefined) {\n    let message = `\n## ${title}\n\n${description}\n`\n    if (recommendation) {\n      message += `\\n${recommendation}`\n    }\n\n    if (code) {\n      message += `\\n${code}`\n    }\n\n    super(message)\n    this.title = title\n    this.description = description\n    this.recommendation = recommendation\n    this.code = code\n  }\n}\n\nfunction filterHighlightLines(codeLines: string[]): { highlights: HighlightPosition[]; queries: QueryPosition[] } {\n  const highlights: HighlightPosition[] = []\n  const queries: QueryPosition[] = []\n\n  let nextContentOffset = 0\n  let contentOffset = 0\n  let removedLines = 0\n\n  for (let i = 0; i < codeLines.length; i++) {\n    const line = codeLines[i]\n    const moveForward = () => {\n      contentOffset = nextContentOffset\n      nextContentOffset += line.length + 1\n    }\n\n    const stripLine = (logDesc: string) => {\n      log(`Removing line ${i} for ${logDesc}`)\n\n      removedLines++\n      codeLines.splice(i, 1)\n      i--\n    }\n\n    // We only need to run regexes over lines with comments\n    if (!line.includes(\"//\")) {\n      moveForward()\n    } else {\n      const highlightMatch = /^\\s*\\/\\/\\s*\\^+( .+)?$/.exec(line)\n      const queryMatch = /^\\s*\\/\\/\\s*\\^\\?\\s*$/.exec(line)\n      // https://regex101.com/r/2yDsRk/1\n      const removePrettierIgnoreMatch = /^\\s*\\/\\/ prettier-ignore$/.exec(line)\n      const completionsQuery = /^\\s*\\/\\/\\s*\\^\\|$/.exec(line)\n\n      if (queryMatch !== null) {\n        const start = line.indexOf(\"^\")\n        queries.push({ kind: \"query\", offset: start, text: undefined, docs: undefined, line: i + removedLines - 1 })\n        stripLine(\"having a query\")\n      } else if (highlightMatch !== null) {\n        const start = line.indexOf(\"^\")\n        const length = line.lastIndexOf(\"^\") - start + 1\n        const description = highlightMatch[1] ? highlightMatch[1].trim() : \"\"\n        highlights.push({\n          kind: \"highlight\",\n          offset: start + contentOffset,\n          length,\n          text: description,\n          line: i + removedLines - 1,\n          start,\n        })\n\n        stripLine(\"having a highlight\")\n      } else if (removePrettierIgnoreMatch !== null) {\n        stripLine(\"being a prettier ignore\")\n      } else if (completionsQuery !== null) {\n        const start = line.indexOf(\"^\")\n        // prettier-ignore\n        queries.push({ kind: \"completion\", offset: start, text: undefined, docs: undefined, line: i + removedLines - 1 })\n        stripLine(\"having a completion query\")\n      } else {\n        moveForward()\n      }\n    }\n  }\n  return { highlights, queries }\n}\n\nfunction getOptionValueFromMap(name: string, key: string, optMap: Map<string, string>) {\n  const result = optMap.get(key.toLowerCase())\n  log(`Get ${name} mapped option: ${key} => ${result}`)\n  if (result === undefined) {\n    const keys = Array.from(optMap.keys() as any)\n\n    throw new TwoslashError(\n      `Invalid inline compiler value`,\n      `Got ${key} for ${name} but it is not a supported value by the TS compiler.`,\n      `Allowed values: ${keys.join(\",\")}`\n    )\n  }\n  return result\n}\n\nfunction setOption(name: string, value: string, opts: CompilerOptions, ts: TS) {\n  log(`Setting ${name} to ${value}`)\n\n  for (const opt of ts.optionDeclarations) {\n    if (opt.name.toLowerCase() === name.toLowerCase()) {\n      switch (opt.type) {\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n          opts[opt.name] = parsePrimitive(value, opt.type)\n          break\n\n        case \"list\":\n          const elementType = opt.element!.type\n          const strings = value.split(\",\")\n          if (typeof elementType === \"string\") {\n            opts[opt.name] = strings.map(v => parsePrimitive(v, elementType))\n          } else {\n            opts[opt.name] = strings.map(v => getOptionValueFromMap(opt.name, v, elementType as Map<string, string>))\n          }\n          break\n\n        default:\n          // It's a map!\n          const optMap = opt.type as Map<string, string>\n          opts[opt.name] = getOptionValueFromMap(opt.name, value, optMap)\n          break\n      }\n      return\n    }\n  }\n\n  throw new TwoslashError(\n    `Invalid inline compiler flag`,\n    `There isn't a TypeScript compiler flag called '${name}'.`,\n    `This is likely a typo, you can check all the compiler flags in the TSConfig reference, or check the additional Twoslash flags in the npm page for @typescript/twoslash.`\n  )\n}\n\nconst booleanConfigRegexp = /^\\/\\/\\s?@(\\w+)$/\n\n// https://regex101.com/r/8B2Wwh/1\nconst valuedConfigRegexp = /^\\/\\/\\s?@(\\w+):\\s?(.+)$/\n\nfunction filterCompilerOptions(codeLines: string[], defaultCompilerOptions: CompilerOptions, ts: TS) {\n  const options = { ...defaultCompilerOptions }\n  for (let i = 0; i < codeLines.length;) {\n    let match\n    if ((match = booleanConfigRegexp.exec(codeLines[i]))) {\n      options[match[1]] = true\n      setOption(match[1], \"true\", options, ts)\n    } else if ((match = valuedConfigRegexp.exec(codeLines[i]))) {\n      // Skip a filename tag, which should propagate through this stage\n      if (match[1] === \"filename\") {\n        i++\n        continue\n      }\n      setOption(match[1], match[2], options, ts)\n    } else {\n      i++\n      continue\n    }\n    codeLines.splice(i, 1)\n  }\n  return options\n}\n\nfunction filterCustomTags(codeLines: string[], customTags: string[]) {\n  const tags: TwoSlashReturn[\"tags\"] = []\n\n  for (let i = 0; i < codeLines.length;) {\n    let match\n    if ((match = valuedConfigRegexp.exec(codeLines[i]))) {\n      if (customTags.includes(match[1])) {\n        tags.push({ name: match[1], line: i, annotation: codeLines[i].split(\"@\" + match[1] + \": \")[1] })\n        codeLines.splice(i, 1)\n      }\n    }\n    i++\n  }\n  return tags\n}\n\n/** Available inline flags which are not compiler flags */\nexport interface ExampleOptions {\n  /** Lets the sample suppress all error diagnostics */\n  noErrors: boolean\n  /** An array of TS error codes, which you write as space separated - this is so the tool can know about unexpected errors */\n  errors: number[]\n  /** Shows the JS equivalent of the TypeScript code instead */\n  showEmit: boolean\n  /**\n   * Must be used with showEmit, lets you choose the file to present instead of the source - defaults to index.js which\n   * means when you just use `showEmit` above it shows the transpiled JS.\n   */\n  showEmittedFile: string\n\n  /** Whether to disable the pre-cache of LSP calls for interesting identifiers, defaults to false */\n  noStaticSemanticInfo: boolean\n  /** Declare that the TypeScript program should edit the fsMap which is passed in, this is only useful for tool-makers, defaults to false */\n  emit: boolean\n  /** Declare that you don't need to validate that errors have corresponding annotations, defaults to false */\n  noErrorValidation: boolean\n}\n\n// Keys in this object are used to filter out handbook options\n// before compiler options are set.\n\nconst defaultHandbookOptions: Partial<ExampleOptions> = {\n  errors: [],\n  noErrors: false,\n  showEmit: false,\n  showEmittedFile: undefined,\n  noStaticSemanticInfo: false,\n  emit: false,\n  noErrorValidation: false,\n}\n\nfunction filterHandbookOptions(codeLines: string[]): ExampleOptions {\n  const options: any = { ...defaultHandbookOptions }\n  for (let i = 0; i < codeLines.length; i++) {\n    let match\n    if ((match = booleanConfigRegexp.exec(codeLines[i]))) {\n      if (match[1] in options) {\n        options[match[1]] = true\n        log(`Setting options.${match[1]} to true`)\n        codeLines.splice(i, 1)\n        i--\n      }\n    } else if ((match = valuedConfigRegexp.exec(codeLines[i]))) {\n      if (match[1] in options) {\n        options[match[1]] = match[2]\n        log(`Setting options.${match[1]} to ${match[2]}`)\n        codeLines.splice(i, 1)\n        i--\n      }\n    }\n  }\n\n  // Edge case the errors object to turn it into a string array\n  if (\"errors\" in options && typeof options.errors === \"string\") {\n    options.errors = options.errors.split(\" \").map(Number)\n    log(\"Setting options.error to \", options.errors)\n  }\n\n  return options\n}\n\nexport interface TwoSlashReturn {\n  /** The output code, could be TypeScript, but could also be a JS/JSON/d.ts */\n  code: string\n\n  /** The new extension type for the code, potentially changed if they've requested emitted results */\n  extension: string\n\n  /** Requests to highlight a particular part of the code */\n  highlights: {\n    kind: \"highlight\"\n    /** The index of the text in the file */\n    start: number\n    /** What line is the highlighted identifier on? */\n    line: number\n    /** At what index in the line does the caret represent  */\n    offset: number\n    /** The text of the token which is highlighted */\n    text?: string\n    /** The length of the token */\n    length: number\n  }[]\n\n  /** An array of LSP responses identifiers in the sample  */\n  staticQuickInfos: {\n    /** The string content of the node this represents (mainly for debugging) */\n    targetString: string\n    /** The base LSP response (the type) */\n    text: string\n    /** Attached JSDoc info */\n    docs: string | undefined\n    /** The index of the text in the file */\n    start: number\n    /** how long the identifier */\n    length: number\n    /** line number where this is found */\n    line: number\n    /** The character on the line */\n    character: number\n  }[]\n\n  /** Requests to use the LSP to get info for a particular symbol in the source */\n  queries: {\n    kind: \"query\" | \"completions\"\n    /** What line is the highlighted identifier on? */\n    line: number\n    /** At what index in the line does the caret represent  */\n    offset: number\n    /** The text of the token which is highlighted */\n    text?: string\n    /** Any attached JSDocs */\n    docs?: string | undefined\n    /** The token start which the query indicates  */\n    start: number\n    /** The length of the token */\n    length: number\n    /** Results for completions at a particular point */\n    completions?: import(\"typescript\").CompletionEntry[]\n    /* Completion prefix e.g. the letters before the cursor in the word so you can filter */\n    completionsPrefix?: string\n  }[]\n\n  /** The extracted twoslash commands for any custom tags passed in via customTags */\n  tags: {\n    /** What was the name of the tag */\n    name: string\n    /** Where was it located in the original source file */\n    line: number\n    /** What was the text after the `// @tag: ` string  (optional because you could do // @tag on it's own line without the ':') */\n    annotation?: string\n  }[]\n\n  /** Diagnostic error messages which came up when creating the program */\n  errors: {\n    renderedMessage: string\n    id: string\n    category: 0 | 1 | 2 | 3\n    code: number\n    start: number | undefined\n    length: number | undefined\n    line: number | undefined\n    character: number | undefined\n  }[]\n\n  /** The URL for this sample in the playground */\n  playgroundURL: string\n}\n\nexport interface TwoSlashOptions {\n  /** Allows setting any of the handbook options from outside the function, useful if you don't want LSP identifiers */\n  defaultOptions?: Partial<ExampleOptions>\n\n  /** Allows setting any of the compiler options from outside the function */\n  defaultCompilerOptions?: CompilerOptions\n\n  /** Allows applying custom transformers to the emit result, only useful with the showEmit output */\n  customTransformers?: CustomTransformers\n\n  /** An optional copy of the TypeScript import, if missing it will be require'd. */\n  tsModule?: TS\n\n  /** Absolute path to the directory to look up built-in TypeScript .d.ts files. */\n  tsLibDirectory?: string\n\n  /** An optional copy of the lz-string import, if missing it will be require'd. */\n  lzstringModule?: LZ\n\n  /**\n   * An optional Map object which is passed into @typescript/vfs - if you are using twoslash on the\n   * web then you'll need this to set up your lib *.d.ts files. If missing, it will use your fs.\n   */\n  fsMap?: Map<string, string>\n\n  /** The cwd for the folder which the virtual fs should be overlaid on top of when using local fs, opts to process.cwd() if not present */\n  vfsRoot?: string\n\n  /** A set of known `// @[tags]` tags to extract and not treat as a comment */\n  customTags?: string[]\n}\n\n/**\n * Runs the checker against a TypeScript/JavaScript code sample returning potentially\n * difference code, and a set of annotations around how it works.\n *\n * @param code The twoslash markup'd code\n * @param extension For example: \"ts\", \"tsx\", \"typescript\", \"javascript\" or \"js\".\n * @param options Additional options for twoslash\n */\nexport function twoslasher(code: string, extension: string, options: TwoSlashOptions = {}): TwoSlashReturn {\n  const ts: TS = options.tsModule ?? require(\"typescript\")\n  const lzstring: LZ = options.lzstringModule ?? require(\"lz-string\")\n\n  const originalCode = code\n  const safeExtension = typesToExtension(extension)\n  const defaultFileName = \"index.\" + safeExtension\n\n  log(`\\n\\nLooking at code: \\n\\`\\`\\`${safeExtension}\\n${code}\\n\\`\\`\\`\\n`)\n\n  const defaultCompilerOptions = {\n    strict: true,\n    target: ts.ScriptTarget.ES2016,\n    allowJs: true,\n    ...(options.defaultCompilerOptions ?? {}),\n  }\n\n  validateInput(code)\n\n  code = cleanMarkdownEscaped(code)\n\n  // NOTE: codeLines is mutated by the below functions:\n  const codeLines = code.split(/\\r\\n?|\\n/g)\n\n  let tags: TwoSlashReturn[\"tags\"] = options.customTags ? filterCustomTags(codeLines, options.customTags) : []\n  const handbookOptions = { ...filterHandbookOptions(codeLines), ...options.defaultOptions }\n  const compilerOptions = filterCompilerOptions(codeLines, defaultCompilerOptions, ts)\n\n  // Handle special casing the lookup for when using jsx preserve which creates .jsx files\n  if (!handbookOptions.showEmittedFile) {\n    handbookOptions.showEmittedFile =\n      compilerOptions.jsx && compilerOptions.jsx === ts.JsxEmit.Preserve ? \"index.jsx\" : \"index.js\"\n  }\n\n  const getRoot = () => {\n    const pa = \"pa\"\n    const path = require(pa + \"th\") as typeof import(\"path\")\n    const rootPath = options.vfsRoot || process.cwd()\n    return rootPath.split(path.sep).join(path.posix.sep)\n  }\n\n  // In a browser we want to DI everything, in node we can use local infra\n  const useFS = !!options.fsMap\n  const vfs = useFS && options.fsMap ? options.fsMap : new Map<string, string>()\n  const system = useFS ? createSystem(vfs) : createFSBackedSystem(vfs, getRoot(), ts, options.tsLibDirectory)\n  const fsRoot = useFS ? \"/\" : getRoot() + \"/\"\n\n  const env = createVirtualTypeScriptEnvironment(system, [], ts, compilerOptions, options.customTransformers)\n  const ls = env.languageService\n\n  code = codeLines.join(\"\\n\")\n\n  let partialQueries = [] as (PartialQueryResults | PartialCompletionResults)[]\n  let queries = [] as TwoSlashReturn[\"queries\"]\n  let highlights = [] as TwoSlashReturn[\"highlights\"]\n\n  const nameContent = splitTwoslashCodeInfoFiles(code, defaultFileName, fsRoot)\n  const sourceFiles = [\"js\", \"jsx\", \"ts\", \"tsx\"]\n\n  /** All of the referenced files in the markup */\n  const filenames = nameContent.map(nc => nc[0])\n\n  for (const file of nameContent) {\n    const [filename, codeLines] = file\n    const filetype = filename.split(\".\").pop() || \"\"\n\n    // Only run the LSP-y things on source files\n    const allowJSON = compilerOptions.resolveJsonModule && filetype === \"json\"\n    if (!sourceFiles.includes(filetype) && !allowJSON) {\n      continue\n    }\n\n    // Create the file in the vfs\n    const newFileCode = codeLines.join(\"\\n\")\n    env.createFile(filename, newFileCode)\n\n    const updates = filterHighlightLines(codeLines)\n    highlights = highlights.concat(updates.highlights)\n\n    // ------ Do the LSP lookup for the queries\n\n    const lspedQueries = updates.queries.map((q, i) => {\n      const sourceFile = env.getSourceFile(filename)!\n      const position = ts.getPositionOfLineAndCharacter(sourceFile, q.line, q.offset)\n      switch (q.kind) {\n        case \"query\": {\n          const quickInfo = ls.getQuickInfoAtPosition(filename, position)\n\n          // prettier-ignore\n          let text: string\n          let docs: string | undefined\n\n          if (quickInfo && quickInfo.displayParts) {\n            text = quickInfo.displayParts.map(dp => dp.text).join(\"\")\n            docs = quickInfo.documentation ? quickInfo.documentation.map(d => d.text).join(\"<br/>\") : undefined\n          } else {\n            throw new TwoslashError(\n              `Invalid QuickInfo query`,\n              `The request on line ${q.line} in ${filename} for quickinfo via ^? returned no from the compiler.`,\n              `This is likely that the x positioning is off.`\n            )\n          }\n\n          const queryResult: PartialQueryResults = {\n            kind: \"query\",\n            text,\n            docs,\n            line: q.line - i,\n            offset: q.offset,\n            file: filename,\n          }\n          return queryResult\n        }\n\n        case \"completion\": {\n          const completions = ls.getCompletionsAtPosition(filename, position - 1, {})\n          if (!completions && !handbookOptions.noErrorValidation) {\n            throw new TwoslashError(\n              `Invalid completion query`,\n              `The request on line ${q.line} in ${filename} for completions via ^| returned no completions from the compiler.`,\n              `This is likely that the positioning is off.`\n            )\n          }\n\n          const word = getClosestWord(sourceFile.text, position - 1)\n          const prefix = sourceFile.text.slice(word.startPos, position)\n          const lastDot = prefix.split(\".\").pop() || \"\"\n\n          const queryResult: PartialCompletionResults = {\n            kind: \"completions\",\n            completions: completions?.entries || [],\n            completionPrefix: lastDot,\n            line: q.line - i,\n            offset: q.offset,\n            file: filename,\n          }\n          return queryResult\n        }\n      }\n    })\n    partialQueries = partialQueries.concat(lspedQueries)\n\n    // Sets the file in the compiler as being without the comments\n    const newEditedFileCode = codeLines.join(\"\\n\")\n    env.updateFile(filename, newEditedFileCode)\n  }\n\n  // We need to also strip the highlights + queries from the main file which is shown to people\n  const allCodeLines = code.split(/\\r\\n?|\\n/g)\n  filterHighlightLines(allCodeLines)\n  code = allCodeLines.join(\"\\n\")\n\n  // Lets fs changes propagate back up to the fsMap\n  if (handbookOptions.emit) {\n    filenames.forEach(f => {\n      const filetype = f.split(\".\").pop() || \"\"\n      if (!sourceFiles.includes(filetype)) return\n\n      const output = ls.getEmitOutput(f)\n      output.outputFiles.forEach(output => {\n        system.writeFile(output.name, output.text)\n      })\n    })\n  }\n\n  // Code should now be safe to compile, so we're going to split it into different files\n  let errs: import(\"typescript\").Diagnostic[] = []\n  // Let because of a filter when cutting\n  let staticQuickInfos: TwoSlashReturn[\"staticQuickInfos\"] = []\n\n  // Iterate through the declared files and grab errors and LSP quickinfos\n  // const declaredFiles = Object.keys(fileMap)\n\n  filenames.forEach(file => {\n    const filetype = file.split(\".\").pop() || \"\"\n\n    // Only run the LSP-y things on source files\n    if (!sourceFiles.includes(filetype)) {\n      return\n    }\n\n    if (!handbookOptions.noErrors) {\n      errs = errs.concat(ls.getSemanticDiagnostics(file), ls.getSyntacticDiagnostics(file))\n    }\n\n    const source = env.sys.readFile(file)!\n    const sourceFile = env.getSourceFile(file)\n    if (!sourceFile) {\n      throw new TwoslashError(\n        `Could not find a  TypeScript sourcefile for '${file}' in the Twoslash vfs`,\n        `It's a little hard to provide useful advice on this error. Maybe you imported something which the compiler doesn't think is a source file?`,\n        ``\n      )\n    }\n\n    // Get all of the interesting quick info popover\n    if (!handbookOptions.showEmit) {\n      const fileContentStartIndexInModifiedFile = code.indexOf(source) == -1 ? 0 : code.indexOf(source)\n      const linesAbove = code.slice(0, fileContentStartIndexInModifiedFile).split(\"\\n\").length - 1\n\n      // Get all interesting identifiers in the file, so we can show hover info for it\n      const identifiers = handbookOptions.noStaticSemanticInfo ? [] : getIdentifierTextSpans(ts, sourceFile)\n      for (const identifier of identifiers) {\n        const span = identifier.span\n        const quickInfo = ls.getQuickInfoAtPosition(file, span.start)\n\n        if (quickInfo && quickInfo.displayParts) {\n          const text = quickInfo.displayParts.map(dp => dp.text).join(\"\")\n          const targetString = identifier.text\n          const docs = quickInfo.documentation ? quickInfo.documentation.map(d => d.text).join(\"\\n\") : undefined\n\n          // Get the position of the\n          const position = span.start + fileContentStartIndexInModifiedFile\n          // Use TypeScript to pull out line/char from the original code at the position + any previous offset\n          const burnerSourceFile = ts.createSourceFile(\"_.ts\", code, ts.ScriptTarget.ES2015)\n          const { line, character } = ts.getLineAndCharacterOfPosition(burnerSourceFile, position)\n\n          staticQuickInfos.push({ text, docs, start: position, length: span.length, line, character, targetString })\n        }\n      }\n\n      // Offset the queries for this file because they are based on the line for that one\n      // specific file, and not the global twoslash document. This has to be done here because\n      // in the above loops, the code for queries/highlights/etc hasn't been stripped yet.\n      partialQueries\n        .filter((q: any) => q.file === file)\n        .forEach(q => {\n          const pos =\n            ts.getPositionOfLineAndCharacter(sourceFile, q.line, q.offset) + fileContentStartIndexInModifiedFile\n\n          switch (q.kind) {\n            case \"query\": {\n              queries.push({\n                docs: q.docs,\n                kind: \"query\",\n                start: pos + fileContentStartIndexInModifiedFile,\n                length: q.text.length,\n                text: q.text,\n                offset: q.offset,\n                line: q.line + linesAbove + 1,\n              })\n              break\n            }\n            case \"completions\": {\n              queries.push({\n                completions: q.completions,\n                kind: \"completions\",\n                start: pos + fileContentStartIndexInModifiedFile,\n                completionsPrefix: q.completionPrefix,\n                length: 1,\n                offset: q.offset,\n                line: q.line + linesAbove + 1,\n              })\n            }\n          }\n        })\n    }\n  })\n\n  const relevantErrors = errs.filter(e => e.file && filenames.includes(e.file.fileName))\n\n  // A validator that error codes are mentioned, so we can know if something has broken in the future\n  if (!handbookOptions.noErrorValidation && relevantErrors.length) {\n    validateCodeForErrors(relevantErrors, handbookOptions, extension, originalCode, fsRoot)\n  }\n\n  let errors: TwoSlashReturn[\"errors\"] = []\n\n  // We can't pass the ts.DiagnosticResult out directly (it can't be JSON.stringified)\n  for (const err of relevantErrors) {\n    const codeWhereErrorLives = env.sys.readFile(err.file!.fileName)!\n    const lineOffset =\n      codeLines.findIndex(line => {\n        if (line.includes(`// @filename: `)) {\n          const fileName = line.split(\"// @filename: \")[1].trim()\n          return err.file!.fileName.endsWith(fileName)\n        }\n        return false\n      }) + 1\n    const fileContentStartIndexInModifiedFile = code.indexOf(codeWhereErrorLives)\n    const renderedMessage = ts.flattenDiagnosticMessageText(err.messageText, \"\\n\")\n    const id = `err-${err.code}-${err.start}-${err.length}`\n    const { line, character } = ts.getLineAndCharacterOfPosition(err.file!, err.start!)\n\n    errors.push({\n      category: err.category,\n      code: err.code,\n      length: err.length,\n      start: err.start ? err.start + fileContentStartIndexInModifiedFile : undefined,\n      line: line + lineOffset,\n      character,\n      renderedMessage,\n      id,\n    })\n  }\n\n  // Handle emitting files\n  if (handbookOptions.showEmit) {\n    // Get the file which created the file we want to show:\n    const emitFilename = handbookOptions.showEmittedFile || defaultFileName\n    const emitSourceFilename =\n      fsRoot + emitFilename.replace(\".jsx\", \"\").replace(\".js\", \"\").replace(/\\.d\\.([^\\.]+\\.)?[cm]?ts$/i, \"\").replace(\".map\", \"\")\n\n    let emitSource = filenames.find(f => f === emitSourceFilename + \".ts\" || f === emitSourceFilename + \".tsx\")\n\n    if (!emitSource && !compilerOptions.outFile) {\n      const allFiles = filenames.join(\", \")\n      // prettier-ignore\n      throw new TwoslashError(\n        `Could not find source file to show the emit for`,\n        `Cannot find the corresponding **source** file  ${emitFilename} for completions via ^| returned no quickinfo from the compiler.`,\n        `Looked for: ${emitSourceFilename} in the vfs - which contains: ${allFiles}`\n      )\n    }\n\n    // Allow outfile, in which case you need any file.\n    if (compilerOptions.outFile) {\n      emitSource = filenames[0]\n    }\n\n    const output = ls.getEmitOutput(emitSource!)\n    const file = output.outputFiles.find(\n      o => o.name === fsRoot + handbookOptions.showEmittedFile || o.name === handbookOptions.showEmittedFile\n    )\n\n    if (!file) {\n      const allFiles = output.outputFiles.map(o => o.name).join(\", \")\n      throw new TwoslashError(\n        `Cannot find the output file in the Twoslash VFS`,\n        `Looking for ${handbookOptions.showEmittedFile} in the Twoslash vfs after compiling`,\n        `Looked for\" ${fsRoot + handbookOptions.showEmittedFile} in the vfs - which contains ${allFiles}.`\n      )\n    }\n\n    code = file.text\n    extension = file.name.split(\".\").pop()!\n\n    // Remove highlights and queries, because it won't work across transpiles,\n    // though I guess source-mapping could handle the transition\n    highlights = []\n    partialQueries = []\n    staticQuickInfos = []\n  }\n\n  const zippedCode = lzstring.compressToEncodedURIComponent(originalCode)\n  const playgroundURL = `https://www.typescriptlang.org/play/#code/${zippedCode}`\n\n  // Cutting happens last, and it means editing the lines and character index of all\n  // the type annotations which are attached to a location\n\n  const cutString = \"// ---cut---\\n\"\n  if (code.includes(cutString)) {\n    // Get the place it is, then find the end and the start of the next line\n    const cutIndex = code.indexOf(cutString) + cutString.length\n    const lineOffset = code.substr(0, cutIndex).split(\"\\n\").length - 1\n\n    // Kills the code shown\n    code = code.split(cutString).pop()!\n\n    // For any type of metadata shipped, it will need to be shifted to\n    // fit in with the new positions after the cut\n    staticQuickInfos.forEach(info => {\n      info.start -= cutIndex\n      info.line -= lineOffset\n    })\n    staticQuickInfos = staticQuickInfos.filter(s => s.start > -1)\n\n    errors.forEach(err => {\n      if (err.start) err.start -= cutIndex\n      if (err.line) err.line -= lineOffset\n    })\n    errors = errors.filter(e => e.start && e.start > -1)\n\n    highlights.forEach(highlight => {\n      highlight.start -= cutIndex\n      highlight.line -= lineOffset\n    })\n\n    highlights = highlights.filter(e => e.start > -1)\n\n    queries.forEach(q => (q.line -= lineOffset))\n    queries = queries.filter(q => q.line > -1)\n\n    tags.forEach(q => (q.line -= lineOffset))\n    tags = tags.filter(q => q.line > -1)\n  }\n\n  const cutAfterString = \"// ---cut-after---\\n\"\n\n  if (code.includes(cutAfterString)) {\n\n    // Get the place it is, then find the end and the start of the next line\n    const cutIndex = code.indexOf(cutAfterString) + cutAfterString.length\n    const lineOffset = code.substr(0, cutIndex).split(\"\\n\").length - 1\n\n    // Kills the code shown, removing any whitespace on the end\n    code = code.split(cutAfterString).shift()!.trimEnd()\n\n    // Cut any metadata after the cutAfterString\n    staticQuickInfos = staticQuickInfos.filter(s => s.line < lineOffset)\n    errors = errors.filter(e => e.line && e.line < lineOffset)\n    highlights = highlights.filter(e => e.line < lineOffset)\n    queries = queries.filter(q => q.line < lineOffset)\n    tags = tags.filter(q => q.line < lineOffset)\n  }\n\n  return {\n    code,\n    extension,\n    highlights,\n    queries,\n    staticQuickInfos,\n    errors,\n    playgroundURL,\n    tags,\n  }\n}\n\nconst splitTwoslashCodeInfoFiles = (code: string, defaultFileName: string, root: string) => {\n  const lines = code.split(/\\r\\n?|\\n/g)\n\n  let nameForFile = code.includes(`@filename: ${defaultFileName}`) ? \"global.ts\" : defaultFileName\n  let currentFileContent: string[] = []\n  const fileMap: Array<[string, string[]]> = []\n\n  for (const line of lines) {\n    if (line.includes(\"// @filename: \")) {\n      fileMap.push([root + nameForFile, currentFileContent])\n      nameForFile = line.split(\"// @filename: \")[1].trim()\n      currentFileContent = []\n    } else {\n      currentFileContent.push(line)\n    }\n  }\n  fileMap.push([root + nameForFile, currentFileContent])\n\n  // Basically, strip these:\n  // [\"index.ts\", []]\n  // [\"index.ts\", [\"\"]]\n  const nameContent = fileMap.filter(n => n[1].length > 0 && (n[1].length > 1 || n[1][0] !== \"\"))\n  return nameContent\n}\n","import { TwoslashError } from \"./\"\n\n/** To ensure that errors are matched up right */\nexport function validateCodeForErrors(\n  relevantErrors: import(\"typescript\").Diagnostic[],\n  handbookOptions: { errors: number[] },\n  extension: string,\n  originalCode: string,\n  vfsRoot: string\n) {\n  const inErrsButNotFoundInTheHeader = relevantErrors.filter(e => !handbookOptions.errors.includes(e.code))\n  const errorsFound = Array.from(new Set(inErrsButNotFoundInTheHeader.map(e => e.code))).join(\" \")\n\n  if (inErrsButNotFoundInTheHeader.length) {\n    const errorsToShow = new Set(relevantErrors.map(e => e.code))\n    const codeToAdd = `// @errors: ${Array.from(errorsToShow).join(\" \")}`\n\n    const missing = handbookOptions.errors.length\n      ? `\\nThe existing annotation specified ${handbookOptions.errors.join(\" \")}`\n      : \"\\nExpected: \" + codeToAdd\n\n    // These get filled by below\n    const filesToErrors: Record<string, import(\"typescript\").Diagnostic[]> = {}\n    const noFiles: import(\"typescript\").Diagnostic[] = []\n\n    inErrsButNotFoundInTheHeader.forEach(d => {\n      const fileRef = d.file?.fileName && d.file.fileName.replace(vfsRoot, \"\")\n      if (!fileRef) noFiles.push(d)\n      else {\n        const existing = filesToErrors[fileRef]\n        if (existing) existing.push(d)\n        else filesToErrors[fileRef] = [d]\n      }\n    })\n\n    const showDiagnostics = (title: string, diags: import(\"typescript\").Diagnostic[]) => {\n      return (\n        `${title}\\n  ` +\n        diags\n          .map(e => {\n            const msg = typeof e.messageText === \"string\" ? e.messageText : e.messageText.messageText\n            return `[${e.code}] ${e.start} - ${msg}`\n          })\n          .join(\"\\n  \")\n      )\n    }\n\n    const innerDiags: string[] = []\n    if (noFiles.length) {\n      innerDiags.push(showDiagnostics(\"Ambient Errors\", noFiles))\n    }\n    Object.keys(filesToErrors).forEach(filepath => {\n      innerDiags.push(showDiagnostics(filepath, filesToErrors[filepath]))\n    })\n\n    const allMessages = innerDiags.join(\"\\n\\n\")\n\n    const newErr = new TwoslashError(\n      `Errors were thrown in the sample, but not included in an errors tag`,\n      `These errors were not marked as being expected: ${errorsFound}. ${missing}`,\n      `Compiler Errors:\\n\\n${allMessages}`\n    )\n\n    newErr.code = `## Code\\n\\n'''${extension}\\n${originalCode}\\n'''`\n    throw newErr\n  }\n}\n\n/** Mainly to warn myself, I've lost a good few minutes to this before */\nexport function validateInput(code: string) {\n  if (code.includes(\"// @errors \")) {\n    throw new TwoslashError(\n      `You have '// @errors ' (with a space)`,\n      `You want '// @errors: ' (with a colon)`,\n      `This is a pretty common typo`\n    )\n  }\n\n  if (code.includes(\"// @filename \")) {\n    throw new TwoslashError(\n      `You have '// @filename ' (with a space)`,\n      `You want '// @filename: ' (with a colon)`,\n      `This is a pretty common typo`\n    )\n  }\n}\n"],"names":["parsePrimitive","value","type","toLowerCase","length","TwoslashError","hasLocalStorage","localStorage","error","hasProcess","process","log","getItem","env","DEBUG","console","_message","_Error","title","description","recommendation","code","_this","message","call","this","_wrapNativeSuper","Error","filterHighlightLines","codeLines","highlights","queries","nextContentOffset","contentOffset","removedLines","_loop","_i","line","moveForward","stripLine","logDesc","splice","includes","highlightMatch","exec","queryMatch","removePrettierIgnoreMatch","completionsQuery","start","indexOf","push","kind","offset","text","undefined","docs","lastIndexOf","trim","i","getOptionValueFromMap","name","key","optMap","result","get","keys","Array","from","join","setOption","opts","ts","_ret","_step","_loop2","opt","elementType","element","strings","split","map","v","_iterator","_createForOfIteratorHelperLoose","optionDeclarations","done","booleanConfigRegexp","valuedConfigRegexp","defaultHandbookOptions","errors","noErrors","showEmit","showEmittedFile","noStaticSemanticInfo","emit","noErrorValidation","extension","options","_options$tsModule","_options$lzstringModu","_options$defaultCompi","tsModule","require","lzstring","lzstringModule","originalCode","safeExtension","types","js","javascript","typescript","tsx","jsx","json","jsn","Object","typesToExtension","defaultFileName","defaultCompilerOptions","_extends","strict","target","ScriptTarget","ES2016","allowJs","validateInput","replace","cleanMarkdownEscaped","tags","customTags","match","annotation","filterCustomTags","handbookOptions","Number","filterHandbookOptions","defaultOptions","compilerOptions","filterCompilerOptions","JsxEmit","Preserve","getRoot","path","pa","vfsRoot","cwd","sep","posix","useFS","fsMap","vfs","Map","system","createSystem","createFSBackedSystem","tsLibDirectory","fsRoot","createVirtualTypeScriptEnvironment","customTransformers","ls","languageService","_step2","partialQueries","nameContent","root","_step5","lines","nameForFile","currentFileContent","fileMap","_iterator5","filter","n","splitTwoslashCodeInfoFiles","sourceFiles","filenames","nc","_loop3","file","filename","filetype","pop","allowJSON","resolveJsonModule","newFileCode","createFile","updates","concat","lspedQueries","q","sourceFile","getSourceFile","position","getPositionOfLineAndCharacter","quickInfo","getQuickInfoAtPosition","displayParts","dp","documentation","d","completions","getCompletionsAtPosition","word","str","pos","String","left","slice","search","right","startPos","getClosestWord","lastDot","entries","completionPrefix","newEditedFileCode","updateFile","_iterator2","allCodeLines","forEach","f","getEmitOutput","outputFiles","output","writeFile","errs","staticQuickInfos","getSemanticDiagnostics","getSyntacticDiagnostics","source","sys","readFile","_step3","fileContentStartIndexInModifiedFile","linesAbove","identifiers","textSpans","checkChildren","node","forEachChild","child","isIdentifier","getStart","span","createTextSpan","end","getText","getIdentifierTextSpans","_iterator3","identifier","targetString","burnerSourceFile","createSourceFile","ES2015","_ts$getLineAndCharact","getLineAndCharacterOfPosition","character","completionsPrefix","relevantErrors","e","fileName","inErrsButNotFoundInTheHeader","errorsFound","Set","errorsToShow","codeToAdd","missing","filesToErrors","noFiles","_d$file","fileRef","existing","showDiagnostics","diags","messageText","innerDiags","filepath","allMessages","newErr","validateCodeForErrors","_step4","_loop4","err","codeWhereErrorLives","lineOffset","findIndex","endsWith","renderedMessage","flattenDiagnosticMessageText","id","_ts$getLineAndCharact2","category","_iterator4","emitFilename","emitSourceFilename","emitSource","find","outFile","allFiles","o","playgroundURL","compressToEncodedURIComponent","cutString","cutIndex","substr","info","s","highlight","cutAfterString","shift","trimEnd"],"mappings":"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"}